# 08. 동적 계획법

## 다이나믹 프로그래밍(Dynamic Programming)이란 ?

- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적을 향상시키는 방법
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
- 다이나믹 프로그래밍의 구현은 일반적을 두 가지 방식(탑다운과 바텀업)으로 구성되어있다.
- 다이나믹 프로그래밍(DP)은 동적 계획법이라고도 부른다.
<br><br>

## 일반적인 프로그래밍 분야에서 동적(Dynamic)의 의미는?

- 자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의미한다.
- 반면에 다이나믹 프로그래밍엣 '다이나믹'은 별다른 의미 없이 사용된 단어이다.
<br><br>

> 동적 계획법의 고안자인 벨만(Richard E. Bellman)은 dynamic이라는 단어가 멋있어서 선택했다고 한다. <br>
    Programming이란 단어는 최적화 연구 분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다. <br>

---

## 다이나믹 프로그래밍의 조건

DP는 다음의 조건을 만족할 때 사용할 수 있다.
    
  1. 최적 부분 구조(Optimal Substructure)
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 경우
  2. 중복되는 부분 문제(Overlapping Subproblem)
    - 동일한 작은 문제를 반복적으로 해결해야하는 경우
<br><br>

## VS 분할 정복(Divide and Conquer)

- DP와 분할 정복은 모두 '최적 부분 구조'를 가질 때 사용할 수 있다.(공통점)
  - 즉, 큰 문제를 작은 문젤 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 상황
- DP와 분할 정복의 차이점은 '부분 문제의 중복'이다.
  - DP 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  - 반면에 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.
<br><br>

## 메모이제이션 (Memoization)이란 ?

- 메모이제이션은 DP를 구현하는 방법 중 하나이다.
- '한 번 계산한 결과를 메모리 공간에 메모하는 기법'이다.
  - 중복되는 부분 문제(Overlapping Subproblem)에 의해 같은 문제를 다시 호출하게되면 메모했던 결과를 그대로 가져온다.
  - 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부른다.
  - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다.
<br><br>

## 메모이제이션 구현 패텬

동적 계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션은 굉장히 자주 구현하게 된다.
그런 만큼 한 가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도, 버그를 찾기도 쉬워진다.

다음과 같은 재귀 함수가 있다고 하자.
<br><br>
```c++
// a오 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```

### 분석
함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 몯 -1로 초기화한다.
1. 항상 기저 사례를 제일 먼저 처리한다.
    - 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 매우 유용하다.
    - 기저 사례를 먼저 확인하지 않고 cache[]에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있기 때문이다.
2. 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 몯 -1로 초기화한다.
    - cache[]의 해당 위치에 적혀 있는 값이 -1이라면 이 값은 계산된 반환 값이 아니라는 것을 알 수 있다.
    - 만약 함수의 반환 값이 음수일 수도 있다면 이 방법은 써먹을 수 없을 것이다.
3. ret가 cache[a][b]에 대한 참조형(reference)이라는 데 유의하자.
    - 실수를 할 가능성을 없애주기 때문이다.
4. C++의 경우 memset()을 이용해 cache[]를 초기화하는 부분이다.
    - 메모이제이션용 배열을 초기화하는 것은 매우 자주 있는일이기 때문에 다중 for문보다 쉽게 초기화할 수 있는 방법을 알아 두면 간편하다.
    - 단, memset()을 배열을 초기화하는 방법은 굉장히 제한적인 경우에만 쓸 수 있는 일이니 유의하자.
<br><br>
```c++
// 코드 8.3 메모이제이션의 사용 예

// 전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFuction(int a, int b) {
    // 기저 사례를 처음에 처리한다.
    if (...) return ...;

    // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
    int& ret = cache[a][b];
    if (ret != -1) return ret;
    
    // 여기에서 답을 계산한다.
    ...
    return ret;
}
int main() {
    // memset()을 이용해 cache 배열을 초기화한다.
    memset(cache, -1, sizeof(cache));
}
```

> memset()은 두 번째 인자로 주어진 값을 주어진 메모리의 모든 바이트에 채운다. <br>
즉,  value가 int형이지만 내부적으로는 unsigned char(1byte)로 변환되어 저장된다. <br>
만약 배열이 32비트나 64비트 정수형이라면, 각 바이트마다 값ㅇ 들어가기 때문에 엉뚱한 수로 초기화될 수 있다. <br>
memset()으로 정수 배열에 0 혹은 -1을 채울 수 있는 이유느 각 바이틍 해당 숫자를 집어넣고 부호 있는 정수형을 해석하면 운 좋게도 해당 숫자와 같아지기 때문이다.
<br>

## 탑다운(Top-Down) vs 바텀업(Bottom-Up)


