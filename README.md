# 08. 동적 계획법

## 다이나믹 프로그래밍(Dynamic Programming)이란 ?

- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적을 향상시키는 방법
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
- 다이나믹 프로그래밍의 구현은 일반적을 두 가지 방식(탑다운과 바텀업)으로 구성되어있다.
- 다이나믹 프로그래밍(DP)은 동적 계획법이라고도 부른다.
<br><br>

## 일반적인 프로그래밍 분야에서 동적(Dynamic)의 의미는?

- 자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의미한다.
- 반면에 다이나믹 프로그래밍엣 '다이나믹'은 별다른 의미 없이 사용된 단어이다.
<br><br>

> 동적 계획법의 고안자인 벨만(Richard E. Bellman)은 dynamic이라는 단어가 멋있어서 선택했다고 한다. <br>
    Programming이란 단어는 최적화 연구 분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다. <br>

---

## 다이나믹 프로그래밍의 조건

DP는 다음의 조건을 만족할 때 사용할 수 있다.
    
  1. 최적 부분 구조(Optimal Substructure)
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 경우
  2. 중복되는 부분 문제(Overlapping Subproblem)
    - 동일한 작은 문제를 반복적으로 해결해야하는 경우
<br><br>

## VS 분할 정복(Divide and Conquer)

- DP와 분할 정복은 모두 '최적 부분 구조'를 가질 때 사용할 수 있다.(공통점)
  - 즉, 큰 문제를 작은 문젤 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 상황
- DP와 분할 정복의 차이점은 '부분 문제의 중복'이다.
  - DP 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
  - 반면에 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.
<br><br>

## 메모이제이션 (Memoization)이란 ?

- 메모이제이션은 DP를 구현하는 방법 중 하나이다.
- '한 번 계산한 결과를 메모리 공간에 메모하는 기법'이다.
  - 중복되는 부분 문제(Overlapping Subproblem)에 의해 같은 문제를 다시 호출하게되면 메모했던 결과를 그대로 가져온다.
  - 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부른다.
  - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다.
<br><br>

## 메모이제이션 구현 패텬

동적 계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션은 굉장히 자주 구현하게 된다. <br>
그런 만큼 한 가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도, 버그를 찾기도 쉬워진다.

다음과 같은 재귀 함수가 있다고 하자.
<br><br>
```c++
// a오 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```

### 분석
함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 몯 -1로 초기화한다.
1. 항상 기저 사례를 제일 먼저 처리한다.
    - 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 매우 유용하다.
    - 기저 사례를 먼저 확인하지 않고 cache[]에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있기 때문이다.
2. 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 몯 -1로 초기화한다.
    - cache[]의 해당 위치에 적혀 있는 값이 -1이라면 이 값은 계산된 반환 값이 아니라는 것을 알 수 있다.
    - 만약 함수의 반환 값이 음수일 수도 있다면 이 방법은 써먹을 수 없을 것이다.
3. ret가 cache[a][b]에 대한 참조형(reference)이라는 데 유의하자.
    - 실수를 할 가능성을 없애주기 때문이다.
4. C++의 경우 memset()을 이용해 cache[]를 초기화하는 부분이다.
    - 메모이제이션용 배열을 초기화하는 것은 매우 자주 있는일이기 때문에 다중 for문보다 쉽게 초기화할 수 있는 방법을 알아 두면 간편하다.
    - 단, memset()을 배열을 초기화하는 방법은 굉장히 제한적인 경우에만 쓸 수 있는 일이니 유의하자.
<br><br>
```c++
// 코드 8.3 메모이제이션의 사용 예

// 전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFuction(int a, int b) {
    // 기저 사례를 처음에 처리한다.
    if (...) return ...;

    // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
    int& ret = cache[a][b];
    if (ret != -1) return ret;
    
    // 여기에서 답을 계산한다.
    ...
    return ret;
}
int main() {
    // memset()을 이용해 cache 배열을 초기화한다.
    memset(cache, -1, sizeof(cache));
}
```

> memset()은 두 번째 인자로 주어진 값을 주어진 메모리의 모든 바이트에 채운다. <br>
즉,  value가 int형이지만 내부적으로는 unsigned char(1byte)로 변환되어 저장된다. <br>
만약 배열이 32비트나 64비트 정수형이라면, 각 바이트마다 값이 들어가기 때문에 엉뚱한 수로 초기화될 수 있다. <br>
memset()으로 정수 배열에 0 혹은 -1을 채울 수 있는 이유느 각 바이틍 해당 숫자를 집어넣고 부호 있는 정수형을 해석하면 운 좋게도 해당 숫자와 같아지기 때문이다.
<br>


## 메모이제이션의 시간 복잡도 분석

메모이제이션의 시간 복잡도를 분석하는 과정이 헷갈릴 수 있다. <br>
각 입력에 대해 함수를 처음을 호출할 때와 다음으로 호출할 때 걸리는 시간이 다르기 때문이다. <br>
그러나 우리는 다음과 같이 간단하게 주먹구구식으로 계산할 수 있는 방법이 있다.

- 결론 : (존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수) <br>
- 뒤에 예제에서 적용해보겠습니다.
<br><br>


## 탑다운(Top-Down) vs 바텀업(Bottom-Up)

DP 문제를 푸는 방법은 탑다운(Top-Down)과 바텀업(Bottom-Up)이 있다. <br>
두 방법 모두 큰 문제를 여러 개의 부분 문제들로 나누어 풀지만, 차이점이 있다. <br>

우리 책에서는 메모이제이션을 이용하는 바텀업 방식을 많이 사용하였다. <br>
하지만 DP의 전형적인 형태는 바텀업(Bottom-Up) 방식이라고 한다. <br>

- 탑다운(Top-Down)
    - 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식
    - 탑다운(메모이제이션) 방식은 '하향식'이라고도 한다.
    - 점화식을 이용하면 이해하기 쉬게 풀 수 있는 장점이 있다.


    예시) 이항 계수(binomial coefficient)의 계산
<br><br>

<p align="center">
<img width="219" alt="스크린샷 2022-01-24 오후 1 54 08" src="https://user-images.githubusercontent.com/91893721/150724146-7f0a8a7c-9fa3-4cab-b30f-3af9055f4a78.png">
    
<br>
이항 계수 점화식 <br><br></p>


```c++
// 코드 8.2 메모이제이션을 이용한 이항 계수의 계산

// -1로 초기화해 둔다.
int cache[30][30];

int bino2(int n, int r) {
    // 기저 사례
    if (r == 0 || n == r) return 1;
    // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
    if (cache[n][r] != -1)
        return cache[n][r];
    // 직접 계산한 뒤 배열에 저장
    return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```
<br><br>

- 바텀업(Bottom-Up)
    - 가장 작은 문제들부터 답을 구해가며 전체 문제의 답을 찾는 방식
    - 바텀업 방식은 '상향식'이라고도 한다.
    - 재귀 호출을 하지 않기 때문에 시간과 메모리 사용량을 줄일 수 있는 장점이 있다.
    - 결과 저장용 리스트는 'DP 테이블'이라고 부른다.
<br><br>

```c++
#include <iostream>
int main(void) {
    // DP 테이블
    int C[30][30];
    
    for (int n=0;n<30;n++)
        for (int r=0;r<=n;r++) {
            if (r == 0 || r == n)
                C[n][r] = 1;
            else
                C[n][r] = C[n-1][r-1] + C[n-1][r];
        }
                
    std::cout << C[5][2] << std::endl;
    std::cout << C[6][2] << std::endl;
    return 0;
}
```


### 시간 복잡도 분석

시간 복잡도 = (존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수) 
<br>
r의 최대치는 n이고  <img src="https://latex.codecogs.com/svg.image?bino2(n,&space;r)\\" title="bino2(n, r)" /> 을 계산하는데 만날 수 있는 부분 문제의 수는 최대 <img src="https://latex.codecogs.com/svg.image?O(n^2)\\" title="O(n^2)" /> 이다. <br>
각 부분 문제를 계산할 때 걸리는 시간은 반복문이 없으니 <img src="https://latex.codecogs.com/svg.image?O(1)\\" title="O(1)" /> 이고, <br>
그러면 위 식에 따라  <img src="https://latex.codecogs.com/svg.image?bino2(n,&space;r)\\" title="bino2(n, r)" /> 을 계산하는데 걸리는 시간 복잡도는 <img src="https://latex.codecogs.com/svg.image?O(n^2)\\" title="O(n^2)" /> 이 된다.
<br><br>

---

## 예제: 외발 뛰기 (문제 ID: JUMPGAME, 난이도: 하)

### 재귀 호출에 시작하기

- 함수 정의
    - jump(y, x) = (y, x)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.

- 점화식
    - jump(y, x) = jump(y+jumpSize, x) || jump(y, x+jumpSize)
<br><br>

```c++
// 코드 8.4 외발 뛰기 문제를 해결하는 재귀 호출 알고리즘

int n, board[100][100];
bool jump(int y, int x) {
    // 기저 사례: 게임판 밖을 벗어난 경우
    if (y >= n || x >= n) return false;
    // 기저 사례: 마지막 칸에 도착한 경우
    if (y == n-1 && x == n-1) return true;

    int jumpSize = board[y][x];
    return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

### 메모이제이션 적용하기

- 위 코드의 문제점
    - 완전 탐색이 포기하기 전까지 만들어야 하는 경롱 개수는 n에 대해 지수적으로 늘어나므로, n=100이면 제한 시간을 초과해 버리게 된다.

여기서 주목할 것은 완전 탐색이 만드는 경로의 수느 엄청나게 많지만 jump()에 주어지는 입력의 개수는 100X100개 뿐이다. <br>
이 경우 비둘기집의 원리에 의해 중복으로 해결되는 부분 문제들이 항상 존재함을 알 수 있다.
<br><br>

```c++
// 코드 8.5 외발 뛰기 문제를 해결하는 동적 계획법 알고리즘

int n, board[100][100];
int cache[100][100];

int jump2(int y, int x) {
    // 기저 사례 처리
    if (y >= n || x >= n) return 0;
    if (y == n-1 && x == n-1) return 1;

    // 메모이제이션
    int& ret = cache[y][x];
    if (ret != -1) return ret;
    int jumpSize = board[y][x];
    return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```

##
